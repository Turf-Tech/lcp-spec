"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[884],{4204(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"verification","title":"6. Verification Protocol","description":"Verification enables consumers to cryptographically prove that delivered context matches agreed specifications without trusting the provider. This is the core mechanism that makes LCP trustless.","source":"@site/docs/verification.md","sourceDirName":".","slug":"/verification","permalink":"/lcp-spec/docs/verification","draft":false,"unlisted":false,"editUrl":"https://github.com/Turf-Tech/lcp-spec/tree/main/website/docs/verification.md","tags":[],"version":"current","lastUpdatedBy":"code-wiki","lastUpdatedAt":1770211386000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7,"sidebar_label":"Verification Protocol"},"sidebar":"docsSidebar","previous":{"title":"Negotiation Protocol","permalink":"/lcp-spec/docs/negotiation"},"next":{"title":"Settlement Protocol","permalink":"/lcp-spec/docs/settlement"}}');var r=i(4848),t=i(8453);const a={sidebar_position:7,sidebar_label:"Verification Protocol"},o="6. Verification Protocol",c={},d=[{value:"6.1 Design Goals",id:"61-design-goals",level:2},{value:"6.2 Verification Dimensions",id:"62-verification-dimensions",level:2},{value:"6.2.1 Provenance Verification",id:"621-provenance-verification",level:3},{value:"Digital Signatures",id:"digital-signatures",level:4},{value:"Chain of Custody",id:"chain-of-custody",level:4},{value:"Merkle Tree Proofs",id:"merkle-tree-proofs",level:4},{value:"6.2.2 Freshness Verification",id:"622-freshness-verification",level:3},{value:"Trusted Timestamping",id:"trusted-timestamping",level:4},{value:"Blockchain Anchoring",id:"blockchain-anchoring",level:4},{value:"Verifiable Delay Functions (VDF)",id:"verifiable-delay-functions-vdf",level:4},{value:"6.2.3 Quality Verification",id:"623-quality-verification",level:3},{value:"Schema Validation",id:"schema-validation",level:4},{value:"Completeness Proofs",id:"completeness-proofs",level:4},{value:"Accuracy Attestation",id:"accuracy-attestation",level:4},{value:"6.2.4 Zero-Knowledge Verification",id:"624-zero-knowledge-verification",level:3},{value:"ZK Range Proofs",id:"zk-range-proofs",level:4},{value:"ZK Schema Compliance",id:"zk-schema-compliance",level:4},{value:"ZK Provenance",id:"zk-provenance",level:4},{value:"6.3 Verification Levels",id:"63-verification-levels",level:2},{value:"6.4 Verification Timing",id:"64-verification-timing",level:2},{value:"Synchronous Verification",id:"synchronous-verification",level:3},{value:"Asynchronous Verification",id:"asynchronous-verification",level:3},{value:"Sampling Verification",id:"sampling-verification",level:3},{value:"6.5 Fraud Proofs",id:"65-fraud-proofs",level:2},{value:"Fraud Proof Structure",id:"fraud-proof-structure",level:3},{value:"Dispute Resolution Flow",id:"dispute-resolution-flow",level:3},{value:"On-Chain Fraud Adjudication",id:"on-chain-fraud-adjudication",level:3},{value:"6.6 Verification Costs",id:"66-verification-costs",level:2},{value:"6.7 Trusted Execution Environments (TEE)",id:"67-trusted-execution-environments-tee",level:2},{value:"TEE Attestation",id:"tee-attestation",level:3},{value:"6.8 Implementation Recommendations",id:"68-implementation-recommendations",level:2},{value:"For Consumers",id:"for-consumers",level:3},{value:"For Providers",id:"for-providers",level:3},{value:"For Verifiers (Third-Party)",id:"for-verifiers-third-party",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"6-verification-protocol",children:"6. Verification Protocol"})}),"\n",(0,r.jsx)(n.p,{children:"Verification enables consumers to cryptographically prove that delivered context matches agreed specifications without trusting the provider. This is the core mechanism that makes LCP trustless."}),"\n",(0,r.jsx)(n.h2,{id:"61-design-goals",children:"6.1 Design Goals"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trustless Verification"}),": Consumers verify claims independently without relying on provider honesty"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Provenance Tracking"}),": Cryptographic proof of context origin and custody chain"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quality Attestation"}),": Measurable guarantees (freshness, completeness, accuracy)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Privacy Preservation"}),": Zero-knowledge proofs enable verification without exposing sensitive data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dispute Resolution"}),": Fraud proofs allow adjudication of disagreements"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"62-verification-dimensions",children:"6.2 Verification Dimensions"}),"\n",(0,r.jsx)(n.h3,{id:"621-provenance-verification",children:"6.2.1 Provenance Verification"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Prove context originated from claimed source and wasn't tampered with."]}),"\n",(0,r.jsx)(n.h4,{id:"digital-signatures",children:"Digital Signatures"}),"\n",(0,r.jsx)(n.p,{children:"Provider signs context hash with their private key:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "data_hash": "0x2c26b46b68ffc68ff99b453c1d30413413422d70",\n  "signature": {\n    "algorithm": "ES256K",\n    "signer": "did:example:provider123",\n    "public_key": "0xabcd...ef01",\n    "signature_value": "0x3045022100a7b2c3d4..."\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Verification:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function verifySignature(data: any, signature: Signature): boolean {\n  const dataHash = sha256(JSON.stringify(data))\n  const publicKey = resolvePublicKey(signature.signer)  // From DID document\n  return ecdsaVerify(dataHash, signature.signature_value, publicKey)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Guarantees"}),": Proves data signed by holder of provider's private key\n",(0,r.jsx)(n.strong,{children:"Limitations"}),": Doesn't prove data quality or original source (only that provider signed it)"]}),"\n",(0,r.jsx)(n.h4,{id:"chain-of-custody",children:"Chain of Custody"}),"\n",(0,r.jsx)(n.p,{children:"For data sourced from third parties, prove custody chain:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "provenance": {\n    "chain_of_custody": [\n      {\n        "entity": "NASDAQ",\n        "role": "original_source",\n        "timestamp": "2026-01-29T12:30:05.200Z",\n        "data_hash": "0x9876...",\n        "signature": "0x5432..."\n      },\n      {\n        "entity": "did:example:provider123",\n        "role": "aggregator",\n        "timestamp": "2026-01-29T12:30:05.250Z",\n        "data_hash": "0x2c26...",  // Hash after transformation\n        "signature": "0x3045...",\n        "transformation": "added_derived_fields"\n      }\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Each entity signs the data hash at their point in the chain. Consumer verifies:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Original source signature is valid"}),"\n",(0,r.jsx)(n.li,{children:"Each subsequent custodian signature is valid"}),"\n",(0,r.jsx)(n.li,{children:"Hash chain is consistent (transformations declared)"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"merkle-tree-proofs",children:"Merkle Tree Proofs"}),"\n",(0,r.jsx)(n.p,{children:"For batch queries or large datasets, use Merkle trees for efficient verification:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "merkle_proof": {\n    "root": "0x2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae",\n    "leaf": {\n      "index": 42,\n      "hash": "0x123abc...",\n      "data": {"symbol": "AAPL", "price": 178.42}\n    },\n    "proof_path": [\n      {"position": "right", "hash": "0xabcd..."},\n      {"position": "left", "hash": "0xef01..."},\n      {"position": "right", "hash": "0x2345..."}\n    ]\n  },\n  "root_signature": {\n    "signer": "did:example:provider123",\n    "signature": "0x3045..."\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Verification:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function verifyMerkleProof(proof: MerkleProof): boolean {\n  let hash = proof.leaf.hash\n\n  for (const step of proof.proof_path) {\n    hash = step.position === 'left'\n      ? sha256(step.hash + hash)\n      : sha256(hash + step.hash)\n  }\n\n  return hash === proof.root && verifySignature(proof.root, proof.root_signature)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"O(log n) proof size for dataset of size n"}),"\n",(0,r.jsx)(n.li,{children:"Prove specific data point is part of committed dataset"}),"\n",(0,r.jsx)(n.li,{children:"Provider commits to all data upfront (can't cherry-pick later)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"622-freshness-verification",children:"6.2.2 Freshness Verification"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Prove context was generated/observed within specified time window."]}),"\n",(0,r.jsx)(n.h4,{id:"trusted-timestamping",children:"Trusted Timestamping"}),"\n",(0,r.jsx)(n.p,{children:"Third-party timestamp authority (TSA) signs data hash with timestamp:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "timestamp_proof": {\n    "authority": "https://timestamp.example.com",\n    "timestamp": "2026-01-29T12:30:05.250Z",\n    "data_hash": "0x2c26b46b...",\n    "signature": "0x5432...",\n    "certificate_chain": [...]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Consumer verifies:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"TSA signature is valid"}),"\n",(0,r.jsx)(n.li,{children:"TSA is in trusted set (e.g., RFC 3161 compliant)"}),"\n",(0,r.jsx)(n.li,{children:"Timestamp is within freshness requirement"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Guarantees"}),": Data existed at claimed time (TSA cannot backdate)\n",(0,r.jsx)(n.strong,{children:"Limitations"}),": Requires trust in TSA (though TSAs are auditable and reputable)"]}),"\n",(0,r.jsx)(n.h4,{id:"blockchain-anchoring",children:"Blockchain Anchoring"}),"\n",(0,r.jsx)(n.p,{children:"Commit data hash to blockchain for immutable timestamping:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "blockchain_timestamp": {\n    "chain": "ethereum",\n    "block_number": 19234567,\n    "block_hash": "0x789xyz...",\n    "block_timestamp": "2026-01-29T12:30:08Z",\n    "transaction_hash": "0xabc123...",\n    "data_hash": "0x2c26b46b..."\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Verification:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function verifyBlockchainTimestamp(proof: BlockchainTimestamp): Promise<boolean> {\n  const block = await web3.eth.getBlock(proof.block_number)\n\n  if (block.hash !== proof.block_hash) return false\n\n  const tx = await web3.eth.getTransaction(proof.transaction_hash)\n  const dataHashInTx = extractDataHash(tx.input)\n\n  return dataHashInTx === proof.data_hash &&\n         block.timestamp === proof.block_timestamp\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Guarantees"}),": Trustless timestamp (blockchain consensus provides ordering)\n",(0,r.jsx)(n.strong,{children:"Limitations"}),": Block time granularity (e.g., ~12s on Ethereum), gas costs"]}),"\n",(0,r.jsx)(n.h4,{id:"verifiable-delay-functions-vdf",children:"Verifiable Delay Functions (VDF)"}),"\n",(0,r.jsx)(n.p,{children:"Prove computation took specific amount of time:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "vdf_proof": {\n    "input": "0x1234...",\n    "output": "0x5678...",\n    "time_parameter": 1000000,  // Number of sequential steps\n    "proof": "0xabcd..."\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),': Prove data was generated "just now" (computation couldn\'t have been done earlier and cached)']}),"\n",(0,r.jsx)(n.h3,{id:"623-quality-verification",children:"6.2.3 Quality Verification"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Prove context meets quality standards (completeness, accuracy, schema compliance)."]}),"\n",(0,r.jsx)(n.h4,{id:"schema-validation",children:"Schema Validation"}),"\n",(0,r.jsx)(n.p,{children:"Prove data matches agreed JSON Schema:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function verifySchemaCompliance(data: any, schemaUrl: string): boolean {\n  const schema = fetchSchema(schemaUrl)\n  const ajv = new Ajv()\n  const validate = ajv.compile(schema)\n  return validate(data)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Guarantees"}),": Data structure matches specification\n",(0,r.jsx)(n.strong,{children:"Limitations"}),": Doesn't verify semantic correctness"]}),"\n",(0,r.jsx)(n.h4,{id:"completeness-proofs",children:"Completeness Proofs"}),"\n",(0,r.jsx)(n.p,{children:"For queries requesting N items, prove N items delivered:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "completeness_proof": {\n    "requested_symbols": ["AAPL", "GOOGL", "MSFT", "TSLA"],\n    "delivered_count": 4,\n    "merkle_root": "0x2c26...",\n    "missing_items": []\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Consumer verifies:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Delivered count matches requested count"}),"\n",(0,r.jsx)(n.li,{children:"Each requested item appears in Merkle tree"}),"\n",(0,r.jsx)(n.li,{children:"No items missing"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"accuracy-attestation",children:"Accuracy Attestation"}),"\n",(0,r.jsx)(n.p,{children:"Third-party verifier attests to data accuracy:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "accuracy_attestation": {\n    "verifier": "did:example:verifier789",\n    "claim": "data_accuracy >= 0.99",\n    "sample_size": 1000,\n    "verification_method": "cross_reference_with_primary_source",\n    "verified_at": "2026-01-29T12:35:00Z",\n    "signature": "0x9876..."\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Model"}),": Verifier independently checks provider's data against ground truth, signs attestation if quality exceeds threshold"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Incentives"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Consumers pay verifiers for attestation"}),"\n",(0,r.jsx)(n.li,{children:"Verifiers stake reputation (slashing if caught attesting to false claims)"}),"\n",(0,r.jsx)(n.li,{children:"Providers benefit from attestation (higher reputation, command premium pricing)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"624-zero-knowledge-verification",children:"6.2.4 Zero-Knowledge Verification"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Prove properties of context without revealing the context itself."]}),"\n",(0,r.jsx)(n.h4,{id:"zk-range-proofs",children:"ZK Range Proofs"}),"\n",(0,r.jsx)(n.p,{children:"Prove value is within range without revealing exact value:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "value_commitment": "0x2c26b46b...",\n  "zk_range_proof": {\n    "claim": "committed_value >= 100 AND committed_value <= 200",\n    "proof": "0x5f7a8e9c...",\n    "proof_system": "bulletproofs"\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Provider proves stock price is within expected range without revealing exact price (useful for privacy-sensitive contexts)"]}),"\n",(0,r.jsx)(n.p,{children:"Verification:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function verifyRangeProof(commitment: string, proof: RangeProof): boolean {\n  return bulletproofsVerify(\n    commitment,\n    proof.claim.min,\n    proof.claim.max,\n    proof.proof\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"zk-schema-compliance",children:"ZK Schema Compliance"}),"\n",(0,r.jsx)(n.p,{children:"Prove data matches schema without revealing data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "data_commitment": "0x2c26b46b...",\n  "zk_schema_proof": {\n    "schema_hash": "0x9876...",\n    "claim": "committed_data matches schema_hash",\n    "proof": "0x5f7a8e9c...",\n    "proof_system": "plonk"\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Prove proprietary model outputs match specified format without revealing outputs"]}),"\n",(0,r.jsx)(n.h4,{id:"zk-provenance",children:"ZK Provenance"}),"\n",(0,r.jsx)(n.p,{children:"Prove data came from specific source without revealing source identity or data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "zk_provenance_proof": {\n    "claim": "data_source in [approved_sources]",\n    "approved_sources_merkle_root": "0x2c26...",\n    "proof": "0x5f7a8e9c...",\n    "proof_system": "groth16"\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Prove data from whitelisted sources (e.g., verified exchanges) without revealing which specific source"]}),"\n",(0,r.jsx)(n.h2,{id:"63-verification-levels",children:"6.3 Verification Levels"}),"\n",(0,r.jsx)(n.p,{children:"Different use cases require different verification rigor:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Level"}),(0,r.jsx)(n.th,{children:"Verifications Required"}),(0,r.jsx)(n.th,{children:"Use Cases"}),(0,r.jsx)(n.th,{children:"Cost"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Basic"})}),(0,r.jsx)(n.td,{children:"Provider signature only"}),(0,r.jsx)(n.td,{children:"Low-value queries, trusted providers"}),(0,r.jsx)(n.td,{children:"Minimal"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Standard"})}),(0,r.jsx)(n.td,{children:"Signature + timestamp + schema"}),(0,r.jsx)(n.td,{children:"Most production use cases"}),(0,r.jsx)(n.td,{children:"Low"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Enhanced"})}),(0,r.jsx)(n.td,{children:"Standard + chain-of-custody + completeness"}),(0,r.jsx)(n.td,{children:"High-value contexts, compliance requirements"}),(0,r.jsx)(n.td,{children:"Medium"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Paranoid"})}),(0,r.jsx)(n.td,{children:"Enhanced + third-party attestation + blockchain anchoring"}),(0,r.jsx)(n.td,{children:"Financial transactions, legal evidence"}),(0,r.jsx)(n.td,{children:"High"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Privacy-Preserving"})}),(0,r.jsx)(n.td,{children:"ZK proofs for all properties"}),(0,r.jsx)(n.td,{children:"Sensitive/proprietary contexts"}),(0,r.jsx)(n.td,{children:"Very High"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Consumers specify required level in request:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "verification_requirements": {\n    "level": "enhanced",\n    "required_proofs": [\n      "cryptographic_signature",\n      "timestamp_verification",\n      "schema_compliance",\n      "chain_of_custody"\n    ],\n    "optional_proofs": [\n      "third_party_attestation"\n    ]\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"64-verification-timing",children:"6.4 Verification Timing"}),"\n",(0,r.jsx)(n.h3,{id:"synchronous-verification",children:"Synchronous Verification"}),"\n",(0,r.jsx)(n.p,{children:"Verification happens before accepting context:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Consumer \u2190\u2500 Context + Proofs \u2500\u2500\u2500 Provider\n    \u2502\n    \u251c\u2500 Verify signature\n    \u251c\u2500 Verify timestamp\n    \u251c\u2500 Verify completeness\n    \u251c\u2500 Verify schema\n    \u2502\n    \u2514\u2500\u25b6 Accept / Reject\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Latency Impact"}),": +10-100ms depending on proof complexity"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Real-time applications where consuming bad data is costly"]}),"\n",(0,r.jsx)(n.h3,{id:"asynchronous-verification",children:"Asynchronous Verification"}),"\n",(0,r.jsx)(n.p,{children:"Accept context immediately, verify in background:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Consumer \u2190\u2500 Context \u2500\u2500\u2500 Provider\n    \u2502\n    \u251c\u2500\u25b6 Use context immediately\n    \u2502\n    \u2570\u2500 (background) \u2500\u25b6 Verify proofs\n         \u2502\n         \u251c\u2500 If valid: Mark as verified, release escrow\n         \u2514\u2500 If invalid: Initiate dispute\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Latency Impact"}),": None on critical path"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Case"}),": Latency-sensitive applications where verification cost > bad data cost"]}),"\n",(0,r.jsx)(n.h3,{id:"sampling-verification",children:"Sampling Verification"}),"\n",(0,r.jsx)(n.p,{children:"Verify random sample, assume rest is valid:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Consumer receives 10,000 data points\n    \u2502\n    \u251c\u2500\u25b6 Randomly sample 100 points (1%)\n    \u251c\u2500\u25b6 Verify Merkle proofs for sampled points\n    \u2502\n    \u2514\u2500\u25b6 If all valid, accept entire dataset\n        If any invalid, verify entire dataset\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cost Reduction"}),": 99% fewer verifications"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Risk"}),": (1-p)^n probability of missing bad data, where p=sample rate, n=bad data count"]}),"\n",(0,r.jsx)(n.h2,{id:"65-fraud-proofs",children:"6.5 Fraud Proofs"}),"\n",(0,r.jsx)(n.p,{children:"When verification fails, consumer generates fraud proof for dispute resolution."}),"\n",(0,r.jsx)(n.h3,{id:"fraud-proof-structure",children:"Fraud Proof Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "fraud_proof": {\n    "proof_id": "fraud_8d7c6b5a4f3e2d1c",\n    "agreement_id": "agr_8d7c6b5a4f3e2d1c",\n    "claim": "provider_delivered_invalid_data",\n    "evidence": {\n      "agreed_terms": {...},\n      "delivered_data": {...},\n      "violation_type": "signature_verification_failed",\n      "verification_trace": {\n        "expected_signer": "did:example:provider123",\n        "signature": "0x3045...",\n        "data_hash": "0x2c26...",\n        "verification_result": false,\n        "error": "signature does not match public key"\n      }\n    },\n    "consumer_signature": "0x1234...",\n    "submitted_at": "2026-01-29T12:35:00Z"\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"dispute-resolution-flow",children:"Dispute Resolution Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1. Consumer generates fraud proof\n2. Consumer submits to dispute resolution system (on-chain or arbitration)\n3. System verifies fraud proof independently\n4. If proof valid:\n   - Provider's reputation slashed\n   - Consumer refunded from provider's bond\n   - Agreement voided\n5. If proof invalid:\n   - Consumer's reputation slashed (frivolous dispute)\n   - Provider keeps payment\n"})}),"\n",(0,r.jsx)(n.h3,{id:"on-chain-fraud-adjudication",children:"On-Chain Fraud Adjudication"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"contract LCPDisputeResolver {\n  struct Dispute {\n    bytes32 agreementHash;\n    address consumer;\n    address provider;\n    bytes fraudProof;\n    DisputeStatus status;\n    uint256 submittedAt;\n  }\n\n  enum DisputeStatus { Pending, ProviderFaultConfirmed, ConsumerFaultConfirmed, Dismissed }\n\n  mapping(bytes32 => Dispute) public disputes;\n\n  function submitDisputefunction submitFraudProof(\n    bytes32 agreementHash,\n    bytes calldata fraudProof\n  ) external {\n    // Store dispute\n    disputes[agreementHash] = Dispute({\n      agreementHash: agreementHash,\n      consumer: msg.sender,\n      provider: getProvider(agreementHash),\n      fraudProof: fraudProof,\n      status: DisputeStatus.Pending,\n      submittedAt: block.timestamp\n    });\n\n    // Lock provider's bond\n    lockBond(getProvider(agreementHash));\n\n    emit DisputeSubmitted(agreementHash, msg.sender);\n  }\n\n  function adjudicateDispute(bytes32 agreementHash) external {\n    Dispute storage dispute = disputes[agreementHash];\n\n    // Verify fraud proof on-chain\n    bool isValidFraud = verifyFraudProof(dispute.fraudProof);\n\n    if (isValidFraud) {\n      // Slash provider, refund consumer\n      slashProvider(dispute.provider, SLASH_AMOUNT);\n      refundConsumer(dispute.consumer, getAgreementAmount(agreementHash));\n      dispute.status = DisputeStatus.ProviderFaultConfirmed;\n    } else {\n      // Penalize consumer for frivolous dispute\n      slashConsumer(dispute.consumer, FRIVOLOUS_DISPUTE_PENALTY);\n      dispute.status = DisputeStatus.ConsumerFaultConfirmed;\n    }\n\n    emit DisputeResolved(agreementHash, dispute.status);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"66-verification-costs",children:"6.6 Verification Costs"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Proof Type"}),(0,r.jsx)(n.th,{children:"Verification Time"}),(0,r.jsx)(n.th,{children:"Proof Size"}),(0,r.jsx)(n.th,{children:"Generation Cost"}),(0,r.jsx)(n.th,{children:"Use Case"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"ECDSA Signature"})}),(0,r.jsx)(n.td,{children:"<1ms"}),(0,r.jsx)(n.td,{children:"65 bytes"}),(0,r.jsx)(n.td,{children:"Negligible"}),(0,r.jsx)(n.td,{children:"Standard provenance"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Merkle Proof"})}),(0,r.jsx)(n.td,{children:"<1ms per step"}),(0,r.jsx)(n.td,{children:"~32 bytes \xd7 log\u2082(n)"}),(0,r.jsx)(n.td,{children:"Negligible"}),(0,r.jsx)(n.td,{children:"Batch data"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Timestamp (TSA)"})}),(0,r.jsx)(n.td,{children:"<5ms"}),(0,r.jsx)(n.td,{children:"~1KB"}),(0,r.jsx)(n.td,{children:"API call cost"}),(0,r.jsx)(n.td,{children:"Freshness"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Blockchain Anchor"})}),(0,r.jsx)(n.td,{children:"<100ms"}),(0,r.jsx)(n.td,{children:"~200 bytes"}),(0,r.jsx)(n.td,{children:"Gas fees ($0.01-$1)"}),(0,r.jsx)(n.td,{children:"Trustless timestamp"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"ZK Range Proof"})}),(0,r.jsx)(n.td,{children:"~50ms"}),(0,r.jsx)(n.td,{children:"~700 bytes"}),(0,r.jsx)(n.td,{children:"~1s generation"}),(0,r.jsx)(n.td,{children:"Privacy-preserving"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"ZK General Circuit"})}),(0,r.jsx)(n.td,{children:"~100-500ms"}),(0,r.jsx)(n.td,{children:"1-5KB"}),(0,r.jsx)(n.td,{children:"~10s generation"}),(0,r.jsx)(n.td,{children:"Complex privacy"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"67-trusted-execution-environments-tee",children:"6.7 Trusted Execution Environments (TEE)"}),"\n",(0,r.jsx)(n.p,{children:"For maximum assurance, run verification inside TEE:"}),"\n",(0,r.jsx)(n.h3,{id:"tee-attestation",children:"TEE Attestation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "tee_attestation": {\n    "enclave": "Intel SGX",\n    "code_hash": "0x2c26b46b...",  // Hash of verification code\n    "data_hash": "0x9876...",       // Hash of data being verified\n    "verification_result": true,\n    "attestation_signature": "0x5432...",  // Signed by Intel\'s attestation key\n    "timestamp": "2026-01-29T12:30:05.500Z"\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Consumer verifies:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Attestation signature from known TEE manufacturer (e.g., Intel)"}),"\n",(0,r.jsx)(n.li,{children:"Code hash matches expected verification logic"}),"\n",(0,r.jsx)(n.li,{children:"Verification result is positive"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Guarantees"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Verification code ran in isolated enclave"}),"\n",(0,r.jsx)(n.li,{children:"Results weren't tampered with"}),"\n",(0,r.jsx)(n.li,{children:"Provider couldn't manipulate verification"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Proprietary algorithms (run in TEE to prevent exposure)"}),"\n",(0,r.jsx)(n.li,{children:"High-security contexts (defense against provider compromise)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"68-implementation-recommendations",children:"6.8 Implementation Recommendations"}),"\n",(0,r.jsx)(n.h3,{id:"for-consumers",children:"For Consumers"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Match Verification to Value"}),': Use "paranoid" mode for high-value transactions, "basic" for low-value']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cache Verified Data"}),": Don't re-verify identical context from same provider"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Async When Possible"}),": Defer verification off critical path for latency-sensitive apps"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automated Dispute Submission"}),": Automatically submit fraud proofs when verification fails"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"for-providers",children:"For Providers"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Include All Proofs Upfront"}),": Don't make consumers request proofs separately"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Merkle Trees"}),": For batch data, commit to Merkle root and provide proofs per-item"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Timestamp Everything"}),": Minimal cost, maximum verifiability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Maintain Chain of Custody"}),": When aggregating from third parties, preserve provenance"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"for-verifiers-third-party",children:"For Verifiers (Third-Party)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stake Reputation"}),": Verifiers should bond assets, slashable for false attestations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transparent Methodology"}),": Publish verification methods for auditability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regular Sampling"}),": Continuously sample provider data to maintain attestations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Conflict of Interest"}),": Disclose relationships with providers being verified"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453(e,n,i){i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);