"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[72],{8274(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"settlement","title":"7. Settlement Protocol","description":"Settlement ensures that context delivery and payment occur atomically\u2014either both succeed or both fail. This eliminates counterparty risk and enables trustless transactions between unfamiliar parties.","source":"@site/docs/settlement.md","sourceDirName":".","slug":"/settlement","permalink":"/lcp-spec/docs/settlement","draft":false,"unlisted":false,"editUrl":"https://github.com/Turf-Tech/lcp-spec/tree/main/website/docs/settlement.md","tags":[],"version":"current","lastUpdatedBy":"code-wiki","lastUpdatedAt":1770211386000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8,"sidebar_label":"Settlement Protocol"},"sidebar":"docsSidebar","previous":{"title":"Verification Protocol","permalink":"/lcp-spec/docs/verification"},"next":{"title":"Trust Model","permalink":"/lcp-spec/docs/trust-model"}}');var s=t(4848),i=t(8453);const a={sidebar_position:8,sidebar_label:"Settlement Protocol"},o="7. Settlement Protocol",c={},l=[{value:"7.1 Design Goals",id:"71-design-goals",level:2},{value:"7.2 Settlement Patterns",id:"72-settlement-patterns",level:2},{value:"7.2.1 Atomic Swap",id:"721-atomic-swap",level:3},{value:"Hash Time-Locked Contract (HTLC)",id:"hash-time-locked-contract-htlc",level:4},{value:"HTLC Flow",id:"htlc-flow",level:4},{value:"7.2.2 Conditional Escrow",id:"722-conditional-escrow",level:3},{value:"Escrow Contract",id:"escrow-contract",level:4},{value:"Escrow Flow",id:"escrow-flow",level:4},{value:"7.2.3 Payment Channels",id:"723-payment-channels",level:3},{value:"Channel Setup",id:"channel-setup",level:4},{value:"Channel Flow",id:"channel-flow",level:4},{value:"7.2.4 Cross-Chain Settlement",id:"724-cross-chain-settlement",level:3},{value:"Atomic Cross-Chain Swap",id:"atomic-cross-chain-swap",level:4},{value:"Bridge-Based Settlement",id:"bridge-based-settlement",level:4},{value:"7.3 Settlement Finality",id:"73-settlement-finality",level:2},{value:"7.4 Multi-Currency Settlement",id:"74-multi-currency-settlement",level:2},{value:"Supported Asset Types",id:"supported-asset-types",level:3},{value:"Currency Negotiation",id:"currency-negotiation",level:3},{value:"7.5 Gas Optimization",id:"75-gas-optimization",level:2},{value:"Batching",id:"batching",level:3},{value:"Layer-2 Settlement",id:"layer-2-settlement",level:3},{value:"Meta-Transactions",id:"meta-transactions",level:3},{value:"7.6 Settlement Receipts",id:"76-settlement-receipts",level:2},{value:"7.7 Failed Settlement Recovery",id:"77-failed-settlement-recovery",level:2},{value:"Timeout Recovery",id:"timeout-recovery",level:3},{value:"Insufficient Balance",id:"insufficient-balance",level:3},{value:"Network Congestion",id:"network-congestion",level:3},{value:"7.8 Regulatory Compliance",id:"78-regulatory-compliance",level:2},{value:"KYC/AML Integration",id:"kycaml-integration",level:3},{value:"Travel Rule Compliance",id:"travel-rule-compliance",level:3},{value:"7.9 Implementation Recommendations",id:"79-implementation-recommendations",level:2},{value:"For Consumers",id:"for-consumers",level:3},{value:"For Providers",id:"for-providers",level:3},{value:"For Protocol Implementers",id:"for-protocol-implementers",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"7-settlement-protocol",children:"7. Settlement Protocol"})}),"\n",(0,s.jsx)(n.p,{children:"Settlement ensures that context delivery and payment occur atomically\u2014either both succeed or both fail. This eliminates counterparty risk and enables trustless transactions between unfamiliar parties."}),"\n",(0,s.jsx)(n.h2,{id:"71-design-goals",children:"7.1 Design Goals"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Atomicity"}),": Context delivery and payment are atomic (all-or-nothing)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Trustless"}),": No trusted intermediary holds funds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Chain-Agnostic"}),": Works across multiple blockchains and payment systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Verification-Conditional"}),": Payment released only after verification succeeds"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dispute-Ready"}),": Supports escrow holds during dispute resolution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Low Latency"}),": Settlement completes in seconds, not minutes"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"72-settlement-patterns",children:"7.2 Settlement Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"721-atomic-swap",children:"7.2.1 Atomic Swap"}),"\n",(0,s.jsx)(n.p,{children:"Direct cryptographic swap between context and payment without intermediaries."}),"\n",(0,s.jsx)(n.h4,{id:"hash-time-locked-contract-htlc",children:"Hash Time-Locked Contract (HTLC)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'contract HTLCContextSettlement {\n  struct Swap {\n    bytes32 secretHash;\n    address consumer;\n    address provider;\n    uint256 amount;\n    uint256 timelock;\n    bytes32 contextHash;\n    bool completed;\n    bool refunded;\n  }\n\n  mapping(bytes32 => Swap) public swaps;\n\n  function initiateSwap(\n    bytes32 secretHash,\n    address provider,\n    bytes32 contextHash,\n    uint256 timelockDuration\n  ) external payable {\n    bytes32 swapId = keccak256(abi.encodePacked(\n      secretHash, msg.sender, provider, block.timestamp\n    ));\n\n    swaps[swapId] = Swap({\n      secretHash: secretHash,\n      consumer: msg.sender,\n      provider: provider,\n      amount: msg.value,\n      timelock: block.timestamp + timelockDuration,\n      contextHash: contextHash,\n      completed: false,\n      refunded: false\n    });\n\n    emit SwapInitiated(swapId, msg.sender, provider, msg.value);\n  }\n\n  function completeSwap(\n    bytes32 swapId,\n    string calldata secret,\n    bytes calldata contextData\n  ) external {\n    Swap storage swap = swaps[swapId];\n\n    require(msg.sender == swap.provider, "Only provider can complete");\n    require(!swap.completed && !swap.refunded, "Already finalized");\n    require(keccak256(abi.encodePacked(secret)) == swap.secretHash, "Invalid secret");\n    require(keccak256(contextData) == swap.contextHash, "Invalid context");\n\n    swap.completed = true;\n    payable(swap.provider).transfer(swap.amount);\n\n    emit SwapCompleted(swapId, secret);\n  }\n\n  function refund(bytes32 swapId) external {\n    Swap storage swap = swaps[swapId];\n\n    require(msg.sender == swap.consumer, "Only consumer can refund");\n    require(block.timestamp > swap.timelock, "Timelock not expired");\n    require(!swap.completed && !swap.refunded, "Already finalized");\n\n    swap.refunded = true;\n    payable(swap.consumer).transfer(swap.amount);\n\n    emit SwapRefunded(swapId);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"htlc-flow",children:"HTLC Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Consumer                      HTLC Contract                      Provider\n    \u2502                               \u2502                               \u2502\n    \u2502\u2500\u2500generate secret_hash\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                               \u2502\n    \u2502                               \u2502                               \u2502\n    \u2502\u2500\u2500initiate(secret_hash, $$)\u2500\u2500\u2500\u25b6\u2502                               \u2502\n    \u2502                               \u251c\u2500 Lock consumer funds          \u2502\n    \u2502                               \u2502                               \u2502\n    \u2502\u2500\u2500share secret_hash\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502\n    \u2502                               \u2502                               \u2502\n    \u2502                               \u2502\u25c0\u2500\u2500complete(secret, context)\u2500\u2500\u2500\u2502\n    \u2502                               \u251c\u2500 Verify secret                \u2502\n    \u2502                               \u251c\u2500 Verify context hash          \u2502\n    \u2502                               \u251c\u2500 Pay provider                 \u2502\n    \u2502                               \u2502                               \u2502\n    \u2502\u25c0\u2500\u2500context + secret\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502                               \u2502                               \u2502\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Atomicity Guarantee"}),": Provider can claim payment only by revealing secret, which happens only after delivering context."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Timelock Safety"}),": If provider doesn't deliver, consumer reclaims funds after timeout."]}),"\n",(0,s.jsx)(n.h3,{id:"722-conditional-escrow",children:"7.2.2 Conditional Escrow"}),"\n",(0,s.jsx)(n.p,{children:"Third-party escrow with verification-based release."}),"\n",(0,s.jsx)(n.h4,{id:"escrow-contract",children:"Escrow Contract"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'contract LCPEscrow {\n  struct EscrowAgreement {\n    bytes32 agreementHash;\n    address consumer;\n    address provider;\n    uint256 amount;\n    bytes32 contextHash;\n    bytes verificationProof;\n    EscrowStatus status;\n    uint256 createdAt;\n    uint256 expiresAt;\n  }\n\n  enum EscrowStatus { Pending, VerificationSubmitted, Released, Disputed, Refunded }\n\n  mapping(bytes32 => EscrowAgreement) public escrows;\n\n  function createEscrow(\n    bytes32 agreementHash,\n    address provider,\n    bytes32 contextHash,\n    uint256 expiryDuration\n  ) external payable {\n    escrows[agreementHash] = EscrowAgreement({\n      agreementHash: agreementHash,\n      consumer: msg.sender,\n      provider: provider,\n      amount: msg.value,\n      contextHash: contextHash,\n      verificationProof: "",\n      status: EscrowStatus.Pending,\n      createdAt: block.timestamp,\n      expiresAt: block.timestamp + expiryDuration\n    });\n\n    emit EscrowCreated(agreementHash, msg.sender, provider, msg.value);\n  }\n\n  function submitVerification(\n    bytes32 agreementHash,\n    bytes calldata verificationProof,\n    bytes calldata contextData\n  ) external {\n    EscrowAgreement storage escrow = escrows[agreementHash];\n\n    require(msg.sender == escrow.provider, "Only provider");\n    require(escrow.status == EscrowStatus.Pending, "Wrong status");\n    require(keccak256(contextData) == escrow.contextHash, "Context mismatch");\n\n    escrow.verificationProof = verificationProof;\n    escrow.status = EscrowStatus.VerificationSubmitted;\n\n    emit VerificationSubmitted(agreementHash);\n  }\n\n  function releaseEscrow(bytes32 agreementHash) external {\n    EscrowAgreement storage escrow = escrows[agreementHash];\n\n    require(msg.sender == escrow.consumer, "Only consumer");\n    require(escrow.status == EscrowStatus.VerificationSubmitted, "Verification not submitted");\n\n    // Consumer verified off-chain and approves release\n    escrow.status = EscrowStatus.Released;\n    payable(escrow.provider).transfer(escrow.amount);\n\n    emit EscrowReleased(agreementHash);\n  }\n\n  function disputeEscrow(bytes32 agreementHash, bytes calldata fraudProof) external {\n    EscrowAgreement storage escrow = escrows[agreementHash];\n\n    require(msg.sender == escrow.consumer, "Only consumer");\n    require(escrow.status == EscrowStatus.VerificationSubmitted, "Wrong status");\n\n    escrow.status = EscrowStatus.Disputed;\n\n    emit EscrowDisputed(agreementHash, fraudProof);\n    // Dispute resolution handled externally (see 6.5)\n  }\n\n  function refundExpired(bytes32 agreementHash) external {\n    EscrowAgreement storage escrow = escrows[agreementHash];\n\n    require(block.timestamp > escrow.expiresAt, "Not expired");\n    require(escrow.status == EscrowStatus.Pending, "Already finalized");\n\n    escrow.status = EscrowStatus.Refunded;\n    payable(escrow.consumer).transfer(escrow.amount);\n\n    emit EscrowRefunded(agreementHash);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"escrow-flow",children:"Escrow Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Consumer              Escrow Contract              Provider\n    \u2502                       \u2502                          \u2502\n    \u2502\u2500\u2500createEscrow($$)\u2500\u2500\u2500\u2500\u25b6\u2502                          \u2502\n    \u2502                       \u251c\u2500 Lock funds             \u2502\n    \u2502                       \u2502                          \u2502\n    \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500context + proofs\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502                       \u2502                          \u2502\n    \u251c\u2500 Verify proofs        \u2502                          \u2502\n    \u2502                       \u2502                          \u2502\n    \u2502\u2500\u2500releaseEscrow()\u2500\u2500\u2500\u2500\u2500\u25b6\u2502                          \u2502\n    \u2502                       \u251c\u2500 Pay provider           \u2502\n    \u2502                       \u2502                          \u2502\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Verification Requirement"}),": Consumer verifies proofs off-chain before approving release."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dispute Path"}),": If verification fails, consumer disputes instead of releasing."]}),"\n",(0,s.jsx)(n.h3,{id:"723-payment-channels",children:"7.2.3 Payment Channels"}),"\n",(0,s.jsx)(n.p,{children:"For recurring transactions with same provider, use off-chain payment channels."}),"\n",(0,s.jsx)(n.h4,{id:"channel-setup",children:"Channel Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'contract LCPPaymentChannel {\n  struct Channel {\n    address consumer;\n    address provider;\n    uint256 deposit;\n    uint256 nonce;\n    uint256 expiresAt;\n    bool closed;\n  }\n\n  mapping(bytes32 => Channel) public channels;\n\n  function openChannel(address provider, uint256 duration) external payable {\n    bytes32 channelId = keccak256(abi.encodePacked(msg.sender, provider, block.timestamp));\n\n    channels[channelId] = Channel({\n      consumer: msg.sender,\n      provider: provider,\n      deposit: msg.value,\n      nonce: 0,\n      expiresAt: block.timestamp + duration,\n      closed: false\n    });\n\n    emit ChannelOpened(channelId, msg.sender, provider, msg.value);\n  }\n\n  function closeChannel(\n    bytes32 channelId,\n    uint256 amountToProvider,\n    uint256 nonce,\n    bytes calldata consumerSignature\n  ) external {\n    Channel storage channel = channels[channelId];\n\n    require(!channel.closed, "Already closed");\n    require(msg.sender == channel.provider, "Only provider");\n\n    // Verify consumer signed this payment\n    bytes32 messageHash = keccak256(abi.encodePacked(\n      channelId, amountToProvider, nonce\n    ));\n    require(verifySignature(messageHash, consumerSignature, channel.consumer), "Invalid signature");\n    require(nonce > channel.nonce, "Stale nonce");\n\n    channel.closed = true;\n\n    // Pay provider, refund consumer\n    payable(channel.provider).transfer(amountToProvider);\n    payable(channel.consumer).transfer(channel.deposit - amountToProvider);\n\n    emit ChannelClosed(channelId, amountToProvider);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"channel-flow",children:"Channel Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Consumer                     Channel                    Provider\n    \u2502                           \u2502                          \u2502\n    \u2502\u2500\u2500openChannel($1000)\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502                          \u2502\n    \u2502                           \u2502                          \u2502\n    \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500context_1 ($10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502\u2500\u2500sign payment_1($10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502\n    \u2502                           \u2502                          \u2502\n    \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500context_2 ($10)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502\u2500\u2500sign payment_2($20)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502\n    \u2502                           \u2502                          \u2502\n    ...                        ...                        ...\n    \u2502                           \u2502                          \u2502\n    \u2502                           \u2502\u25c0\u2500\u2500closeChannel($200)\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502                           \u251c\u2500 Pay provider $200      \u2502\n    \u2502                           \u251c\u2500 Refund consumer $800   \u2502\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Instant settlement for each context delivery (off-chain signature)"}),"\n",(0,s.jsx)(n.li,{children:"Low cost (single on-chain transaction for 100+ deliveries)"}),"\n",(0,s.jsx)(n.li,{children:"Suitable for high-frequency, low-value transactions"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Limitations"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Requires upfront deposit (capital lockup)"}),"\n",(0,s.jsx)(n.li,{children:"Channel must be closed eventually (on-chain transaction)"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"724-cross-chain-settlement",children:"7.2.4 Cross-Chain Settlement"}),"\n",(0,s.jsx)(n.p,{children:"When consumer and provider are on different chains:"}),"\n",(0,s.jsx)(n.h4,{id:"atomic-cross-chain-swap",children:"Atomic Cross-Chain Swap"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Consumer (Ethereum)          Provider (Polygon)\n    \u2502                               \u2502\n    \u2502\u2500\u2500lock ETH on Ethereum\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502  with secret_hash             \u2502\n    \u2502                               \u2502\n    \u2502                               \u251c\u2500 lock MATIC on Polygon\n    \u2502                               \u2502  with same secret_hash\n    \u2502                               \u2502\n    \u2502\u25c0\u2500\u2500\u2500context + secret\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502                               \u2502\n    \u2502\u2500\u2500claim MATIC on Polygon\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502  using secret                 \u2502\n    \u2502                               \u2502\n    \u2502                               \u251c\u2500 claim ETH on Ethereum\n    \u2502                               \u2502  using revealed secret\n"})}),"\n",(0,s.jsx)(n.p,{children:"Both parties set timelocks. If swap doesn't complete, both reclaim their locked funds."}),"\n",(0,s.jsx)(n.h4,{id:"bridge-based-settlement",children:"Bridge-Based Settlement"}),"\n",(0,s.jsx)(n.p,{children:"Use trusted bridge for faster (but trust-requiring) settlement:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Consumer (Ethereum)          Bridge          Provider (Polygon)\n    \u2502                          \u2502                    \u2502\n    \u2502\u2500\u2500pay USDC on Ethereum\u2500\u2500\u2500\u25b6\u2502                    \u2502\n    \u2502                          \u251c\u2500 Bridge USDC       \u2502\n    \u2502                          \u2502                    \u2502\n    \u2502                          \u251c\u2500\u2500\u2500\u2500\u2500mint USDC\u2500\u2500\u2500\u2500\u2500\u25b6\u2502\n    \u2502                          \u2502   on Polygon       \u2502\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Trust Assumption"}),": Bridge operators are honest (multi-sig, relayer network)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Speed"}),": ~5-30 minutes depending on bridge"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cost"}),": Bridge fees (0.05-0.5% typical)"]}),"\n",(0,s.jsx)(n.h2,{id:"73-settlement-finality",children:"7.3 Settlement Finality"}),"\n",(0,s.jsx)(n.p,{children:"Different settlement mechanisms offer different finality guarantees:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Settlement Type"}),(0,s.jsx)(n.th,{children:"Finality Time"}),(0,s.jsx)(n.th,{children:"Reversibility"}),(0,s.jsx)(n.th,{children:"Trust Required"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"HTLC"})}),(0,s.jsx)(n.td,{children:"1-2 blocks (~15-30s)"}),(0,s.jsx)(n.td,{children:"Irreversible after timelock"}),(0,s.jsx)(n.td,{children:"None"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Escrow (on-chain)"})}),(0,s.jsx)(n.td,{children:"1-2 blocks"}),(0,s.jsx)(n.td,{children:"Reversible during dispute period"}),(0,s.jsx)(n.td,{children:"Contract correctness"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Payment Channel"})}),(0,s.jsx)(n.td,{children:"Instant (off-chain)"}),(0,s.jsx)(n.td,{children:"Reversible until channel close"}),(0,s.jsx)(n.td,{children:"Counterparty honesty"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Cross-Chain Atomic"})}),(0,s.jsx)(n.td,{children:"Max of both chains (~30-60s)"}),(0,s.jsx)(n.td,{children:"Irreversible after both locks claimed"}),(0,s.jsx)(n.td,{children:"None"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Bridge"})}),(0,s.jsx)(n.td,{children:"~5-30 min"}),(0,s.jsx)(n.td,{children:"Irreversible after bridge finalization"}),(0,s.jsx)(n.td,{children:"Bridge operators"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Lightning/L2"})}),(0,s.jsx)(n.td,{children:"<1s"}),(0,s.jsx)(n.td,{children:"Irreversible after commitment"}),(0,s.jsx)(n.td,{children:"L2 security assumptions"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"74-multi-currency-settlement",children:"7.4 Multi-Currency Settlement"}),"\n",(0,s.jsx)(n.p,{children:"LCP supports settlement in multiple currencies/tokens:"}),"\n",(0,s.jsx)(n.h3,{id:"supported-asset-types",children:"Supported Asset Types"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Native Tokens"}),": ETH, MATIC, BNB, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stablecoins"}),": USDC, USDT, DAI (preferred for price stability)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Protocol Tokens"}),": Custom LCP ecosystem tokens (potential future)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Wrapped Assets"}),": WETH, WBTC, etc."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"currency-negotiation",children:"Currency Negotiation"}),"\n",(0,s.jsx)(n.p,{children:"Included in negotiation phase:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "terms": {\n    "price": {\n      "amount": 0.0015,\n      "currency": "USDC",\n      "chain": "polygon",\n      "token_address": "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"\n    },\n    "accepted_alternatives": [\n      {\n        "currency": "USDT",\n        "chain": "polygon",\n        "token_address": "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",\n        "amount": 0.0015\n      },\n      {\n        "currency": "ETH",\n        "chain": "ethereum",\n        "amount": 0.0000006  // Equivalent value\n      }\n    ]\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Provider specifies preferred currency and acceptable alternatives. Consumer chooses from list."}),"\n",(0,s.jsx)(n.h2,{id:"75-gas-optimization",children:"7.5 Gas Optimization"}),"\n",(0,s.jsx)(n.p,{children:"On-chain settlement gas costs can be significant. Optimization strategies:"}),"\n",(0,s.jsx)(n.h3,{id:"batching",children:"Batching"}),"\n",(0,s.jsx)(n.p,{children:"Batch multiple settlements into single transaction:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:"function batchSettlement(\n  bytes32[] calldata agreementHashes,\n  address[] calldata providers,\n  uint256[] calldata amounts\n) external {\n  for (uint i = 0; i < agreementHashes.length; i++) {\n    settleAgreement(agreementHashes[i], providers[i], amounts[i]);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Savings"}),": ~75% gas reduction for 10 settlements vs individual transactions"]}),"\n",(0,s.jsx)(n.h3,{id:"layer-2-settlement",children:"Layer-2 Settlement"}),"\n",(0,s.jsx)(n.p,{children:"Use L2s (Optimism, Arbitrum, Polygon) for 10-100x cheaper settlement:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Chain"}),(0,s.jsx)(n.th,{children:"Avg Settlement Cost"}),(0,s.jsx)(n.th,{children:"Finality Time"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Ethereum L1"})}),(0,s.jsx)(n.td,{children:"$5-50"}),(0,s.jsx)(n.td,{children:"15s"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Polygon"})}),(0,s.jsx)(n.td,{children:"$0.01-0.10"}),(0,s.jsx)(n.td,{children:"2s"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Arbitrum"})}),(0,s.jsx)(n.td,{children:"$0.10-1.00"}),(0,s.jsx)(n.td,{children:"15s + L1 finality"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Optimism"})}),(0,s.jsx)(n.td,{children:"$0.10-1.00"}),(0,s.jsx)(n.td,{children:"15s + L1 finality"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"meta-transactions",children:"Meta-Transactions"}),"\n",(0,s.jsx)(n.p,{children:"Provider pays gas, consumer signs authorization:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-solidity",children:'function metaSettlement(\n  bytes32 agreementHash,\n  uint256 deadline,\n  bytes calldata consumerSignature\n) external {\n  // Verify consumer authorized this settlement\n  require(verifyMetaTxSignature(agreementHash, deadline, consumerSignature), "Invalid signature");\n\n  // Provider pays gas, consumer\'s payment released to provider\n  settleAgreement(agreementHash);\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefit"}),": Consumer doesn't need native tokens for gas"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cost"}),": Provider pays gas (can be factored into pricing)"]}),"\n",(0,s.jsx)(n.h2,{id:"76-settlement-receipts",children:"7.6 Settlement Receipts"}),"\n",(0,s.jsx)(n.p,{children:"After settlement, both parties receive cryptographic receipt (see 3.6):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "receipt_id": "receipt_5b4a3f2e1d0c9876",\n  "request_id": "req_9f3e8d7c6b5a4321",\n  "settlement": {\n    "chain": "polygon",\n    "transaction_hash": "0xabc123def456...",\n    "block_number": 52341890,\n    "confirmations": 12\n  },\n  "amount": {\n    "amount": 0.0012,\n    "currency": "USDC"\n  },\n  "signatures": {\n    "consumer": "0x1234...",\n    "provider": "0x5678..."\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Receipts enable:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Accounting"}),": Track spending/revenue"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reputation"}),": Prove transaction history"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Disputes"}),": Evidence for arbitration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compliance"}),": Audit trail for regulations"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"77-failed-settlement-recovery",children:"7.7 Failed Settlement Recovery"}),"\n",(0,s.jsx)(n.h3,{id:"timeout-recovery",children:"Timeout Recovery"}),"\n",(0,s.jsx)(n.p,{children:"If settlement doesn't complete within timeout:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'async function settlementWithTimeout(\n  agreement: Agreement,\n  timeoutMs: number\n): Promise<SettlementReceipt> {\n  try {\n    return await Promise.race([\n      executeSettlement(agreement),\n      sleep(timeoutMs).then(() => Promise.reject(new Error("Settlement timeout")))\n    ])\n  } catch (error) {\n    if (error.message === "Settlement timeout") {\n      // Initiate refund\n      await refundEscrow(agreement.escrowAddress)\n      throw new SettlementTimeoutError(agreement.id)\n    }\n    throw error\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"insufficient-balance",children:"Insufficient Balance"}),"\n",(0,s.jsx)(n.p,{children:"If consumer's balance insufficient:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function ensureSufficientBalance(\n  consumer: Address,\n  amount: bigint,\n  token: Address\n): Promise<void> {\n  const balance = await getBalance(consumer, token)\n\n  if (balance < amount) {\n    throw new InsufficientBalanceError({\n      required: amount,\n      available: balance,\n      deficit: amount - balance\n    })\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Consumer should check before initiating negotiation."}),"\n",(0,s.jsx)(n.h3,{id:"network-congestion",children:"Network Congestion"}),"\n",(0,s.jsx)(n.p,{children:"If blockchain is congested (high gas):"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Option 1: Wait"})," for gas prices to drop\n",(0,s.jsx)(n.strong,{children:"Option 2: Switch chains"})," (settle on cheaper L2)\n",(0,s.jsx)(n.strong,{children:"Option 3: Payment channel"})," (settle off-chain, batch later)"]}),"\n",(0,s.jsx)(n.h2,{id:"78-regulatory-compliance",children:"7.8 Regulatory Compliance"}),"\n",(0,s.jsx)(n.h3,{id:"kycaml-integration",children:"KYC/AML Integration"}),"\n",(0,s.jsx)(n.p,{children:"For regulated contexts, integrate identity verification:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "settlement": {\n    "compliance": {\n      "consumer_kyc": {\n        "provider": "identity_provider_xyz",\n        "status": "verified",\n        "verified_at": "2026-01-15T00:00:00Z"\n      },\n      "provider_kyc": {\n        "provider": "identity_provider_xyz",\n        "status": "verified",\n        "verified_at": "2026-01-10T00:00:00Z"\n      },\n      "jurisdiction": "US",\n      "tax_reporting_required": true\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"travel-rule-compliance",children:"Travel Rule Compliance"}),"\n",(0,s.jsx)(n.p,{children:"For transactions >$1000 (or jurisdiction threshold), include counterparty information:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "travel_rule_data": {\n    "originator": {\n      "name": "AgentCorp Inc",\n      "address": "123 AI Street, SF, CA",\n      "account": "0x1234..."\n    },\n    "beneficiary": {\n      "name": "DataProvider LLC",\n      "address": "456 Context Ave, NY, NY",\n      "account": "0x5678..."\n    },\n    "amount_usd": 1500\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"79-implementation-recommendations",children:"7.9 Implementation Recommendations"}),"\n",(0,s.jsx)(n.h3,{id:"for-consumers",children:"For Consumers"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Escrow for New Providers"}),": Use escrow for first transactions with unknown providers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Channels for Repeat Providers"}),": Switch to payment channels after establishing trust"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"L2 by Default"}),": Settle on Polygon/Arbitrum unless L1 security required"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor Finality"}),": Don't assume settlement complete until sufficient confirmations"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"for-providers",children:"For Providers"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Accept Stablecoins"}),": USDC/USDT avoid price volatility risk"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Chain Support"}),": Support Ethereum + at least 2 L2s for optionality"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Batch Settlements"}),": Collect payments and batch-settle to reduce gas costs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Meta-Transactions"}),": Offer gas-free experience for consumers"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"for-protocol-implementers",children:"For Protocol Implementers"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Atomic Primitives"}),": HTLCs and escrows are safest patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timeout Enforcement"}),": Always include timelocks for refund paths"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Receipt Generation"}),": Provide cryptographic receipts for all settlements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-Chain Support"}),": Abstract chain differences behind unified interface"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);