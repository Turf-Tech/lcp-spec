"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[899],{1920(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"introduction","title":"1. Introduction","description":"1.1 The Problem","source":"@site/docs/introduction.md","sourceDirName":".","slug":"/introduction","permalink":"/lcp-spec/docs/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/Turf-Tech/lcp-spec/tree/main/website/docs/introduction.md","tags":[],"version":"current","lastUpdatedBy":"code-wiki","lastUpdatedAt":1770211386000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Introduction"},"sidebar":"docsSidebar","previous":{"title":"Overview","permalink":"/lcp-spec/docs/intro"},"next":{"title":"Architecture","permalink":"/lcp-spec/docs/architecture"}}');var s=t(4848),r=t(8453);const o={sidebar_position:2,sidebar_label:"Introduction"},a="1. Introduction",l={},c=[{value:"1.1 The Problem",id:"11-the-problem",level:2},{value:"The Current Landscape",id:"the-current-landscape",level:3},{value:"What&#39;s Missing",id:"whats-missing",level:3},{value:"1.2 The Thesis",id:"12-the-thesis",level:2},{value:"1.3 Design Principles",id:"13-design-principles",level:2},{value:"1. Protocol-Optimized Coordination",id:"1-protocol-optimized-coordination",level:3},{value:"2. Trustless by Design",id:"2-trustless-by-design",level:3},{value:"3. Permissionless Discovery",id:"3-permissionless-discovery",level:3},{value:"4. Atomic Settlement",id:"4-atomic-settlement",level:3},{value:"5. Verifiable Provenance",id:"5-verifiable-provenance",level:3},{value:"6. Composability Over Integration",id:"6-composability-over-integration",level:3},{value:"1.4 Scope",id:"14-scope",level:2},{value:"What LCP Specifies",id:"what-lcp-specifies",level:3},{value:"What LCP Does Not Specify",id:"what-lcp-does-not-specify",level:3},{value:"1.5 Value Proposition",id:"15-value-proposition",level:2},{value:"For AI Agent Developers",id:"for-ai-agent-developers",level:3},{value:"For Context Providers",id:"for-context-providers",level:3},{value:"For the Ecosystem",id:"for-the-ecosystem",level:3},{value:"1.6 Relationship to Existing Protocols",id:"16-relationship-to-existing-protocols",level:2}];function d(e){const n={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"1-introduction",children:"1. Introduction"})}),"\n",(0,s.jsx)(n.h2,{id:"11-the-problem",children:"1.1 The Problem"}),"\n",(0,s.jsx)(n.p,{children:"AI agents are proliferating rapidly. By end of 2026, Gartner predicts 40% of enterprise applications will include task-specific AI agents. Yet these agents face a fundamental constraint: they cannot autonomously discover, evaluate, negotiate for, and consume the contextual data they need to operate effectively."}),"\n",(0,s.jsx)(n.h3,{id:"the-current-landscape",children:"The Current Landscape"}),"\n",(0,s.jsx)(n.p,{children:"Recent developments have addressed parts of this challenge:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Model Context Protocol (MCP)"}),' provides standardized connections between AI systems and data sources\u2014the "USB-C for AI"\u2014achieving massive adoption (97M+ monthly SDK downloads by December 2025, now stewarded by the Agentic AI Foundation under Linux Foundation)']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Agent2Agent (A2A)"})," from Google enables direct agent-to-agent negotiation and coordination, with support from 50+ technology partners including Salesforce, ServiceNow, and major consultancies"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ERC-8004"})," on Ethereum establishes on-chain identity, reputation, and validation registries for autonomous agents operating in trustless environments"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"whats-missing",children:"What's Missing"}),"\n",(0,s.jsxs)(n.p,{children:["While MCP solves the ",(0,s.jsx)(n.em,{children:"connection"})," problem (how agents access data sources) and A2A addresses ",(0,s.jsx)(n.em,{children:"coordination"})," (how agents communicate), neither addresses the ",(0,s.jsx)(n.em,{children:"orchestration"})," problem: how agents autonomously discover unfamiliar context sources, evaluate their quality and trustworthiness, negotiate acceptable terms, verify provenance cryptographically, and settle payments atomically\u2014all without trusted intermediaries."]}),"\n",(0,s.jsx)(n.p,{children:"Consider an AI agent tasked with analyzing supply chain risk. It needs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Discovery"}),": Finding specialized data providers it has never interacted with before"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Evaluation"}),": Assessing data quality, freshness, and provenance without prior reputation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Negotiation"}),": Determining acceptable terms (price, latency, schema, guarantees) through machine-to-machine bargaining"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Verification"}),": Cryptographic proof that delivered context matches agreed specifications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Settlement"}),": Atomic payment that eliminates counterparty risk"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Today, each of these requires human intermediation, platform gatekeepers, or pre-established trust relationships. This doesn't scale to the autonomous agent economy."}),"\n",(0,s.jsx)(n.h2,{id:"12-the-thesis",children:"1.2 The Thesis"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Contemporary AI systems lack a protocol-level mechanism for autonomously discovering, evaluating, negotiating, and consuming contextual data across untrusted, heterogeneous environments."})}),"\n",(0,s.jsxs)(n.p,{children:["This missing layer\u2014call it the ",(0,s.jsx)(n.em,{children:"context orchestration layer"}),"\u2014sits between application logic and provisioning infrastructure. It is not the pipes through which context flows (transport), nor the endpoints that serve it (providers), nor the standardized interfaces for connection (MCP). Rather, it is the protocol by which agents autonomously determine ",(0,s.jsx)(n.em,{children:"what"})," context they need, ",(0,s.jsx)(n.em,{children:"where"})," to get it, ",(0,s.jsx)(n.em,{children:"on what terms"}),", ",(0,s.jsx)(n.em,{children:"with what guarantees"}),", and ",(0,s.jsx)(n.em,{children:"how to settle payment"}),"\u2014all without human oversight or trusted intermediaries."]}),"\n",(0,s.jsx)(n.p,{children:"The Liquid Context Protocol (LCP) provides this missing orchestration layer through four core mechanisms:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Permissionless Discovery"})," \u2014 Agents find context providers through decentralized registries without gatekeepers determining what's discoverable"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Autonomous Negotiation"})," \u2014 Machine-to-machine bargaining over terms (price, quality, schema, latency) with multi-round proposal/counter-proposal flows"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cryptographic Verification"})," \u2014 Provenance proofs, quality attestations, and freshness guarantees enforced through cryptography rather than provider promises"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Atomic Settlement"})," \u2014 Trustless payment mechanisms that eliminate counterparty risk through escrow, atomic swaps, or on-chain settlement"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By separating orchestration concerns from transport and provisioning, LCP enables a permissionless market for AI context\u2014one where agents can transact with unfamiliar providers, verify claims independently, and settle without intermediaries."}),"\n",(0,s.jsx)(n.h2,{id:"13-design-principles",children:"1.3 Design Principles"}),"\n",(0,s.jsx)(n.h3,{id:"1-protocol-optimized-coordination",children:"1. Protocol-Optimized Coordination"}),"\n",(0,s.jsxs)(n.p,{children:["LCP is not a transport layer (HTTP, WebSocket, P2P) nor a provisioning system (databases, APIs, file systems). It is the ",(0,s.jsx)(n.em,{children:"orchestration"})," layer that enables agents to autonomously determine what context they need and how to obtain it. This separation of concerns allows LCP to work with any underlying infrastructure."]}),"\n",(0,s.jsx)(n.h3,{id:"2-trustless-by-design",children:"2. Trustless by Design"}),"\n",(0,s.jsx)(n.p,{children:"All guarantees\u2014quality, freshness, provenance, settlement finality\u2014are enforced through cryptographic proofs and protocol mechanisms, not provider promises. An agent transacting with an unknown provider has the same security guarantees as one working with a familiar partner."}),"\n",(0,s.jsx)(n.h3,{id:"3-permissionless-discovery",children:"3. Permissionless Discovery"}),"\n",(0,s.jsx)(n.p,{children:"No central authority decides which providers are discoverable. Any provider can advertise capabilities; any consumer can query registries. Reputation and filtering happen at the protocol layer through cryptographic reputation systems (inspired by ERC-8004), not gatekeeping."}),"\n",(0,s.jsx)(n.h3,{id:"4-atomic-settlement",children:"4. Atomic Settlement"}),"\n",(0,s.jsx)(n.p,{children:"Context delivery and payment settlement occur atomically\u2014either both succeed or both fail. This eliminates counterparty risk through escrow mechanisms, atomic swaps, or smart contract settlement, ensuring providers get paid and consumers get what they paid for."}),"\n",(0,s.jsx)(n.h3,{id:"5-verifiable-provenance",children:"5. Verifiable Provenance"}),"\n",(0,s.jsx)(n.p,{children:"Every piece of context carries cryptographic proof of its origin, timestamp, and integrity. Zero-knowledge proofs enable verification without exposing sensitive data. Third-party verifiers can attest to quality without becoming trusted intermediaries."}),"\n",(0,s.jsx)(n.h3,{id:"6-composability-over-integration",children:"6. Composability Over Integration"}),"\n",(0,s.jsx)(n.p,{children:"LCP is designed to complement, not replace, existing protocols. It integrates with MCP for data access, A2A for agent coordination, ERC-8004 for reputation, and blockchain settlement layers. The goal is protocol interoperability, not a monolithic standard."}),"\n",(0,s.jsx)(n.h2,{id:"14-scope",children:"1.4 Scope"}),"\n",(0,s.jsx)(n.h3,{id:"what-lcp-specifies",children:"What LCP Specifies"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Discovery Layer"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"How context providers advertise capabilities through structured descriptors"}),"\n",(0,s.jsx)(n.li,{children:"Registry architectures (DHT, on-chain, federated) for permissionless provider discovery"}),"\n",(0,s.jsx)(n.li,{children:"Query semantics for consumers to find providers matching requirements"}),"\n",(0,s.jsx)(n.li,{children:"Filtering and ranking mechanisms based on capabilities, reputation, and cost"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Negotiation Protocol"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multi-round negotiation flows (proposal, counter-proposal, acceptance)"}),"\n",(0,s.jsx)(n.li,{children:"Terms structure covering pricing, quality guarantees, freshness, latency, schema"}),"\n",(0,s.jsx)(n.li,{children:"Timeout and cancellation handling"}),"\n",(0,s.jsx)(n.li,{children:"Atomic commitment mechanisms ensuring both parties are bound simultaneously"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Verification Framework"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cryptographic provenance proofs (signatures, Merkle trees, timestamping)"}),"\n",(0,s.jsx)(n.li,{children:"Quality attestation mechanisms"}),"\n",(0,s.jsx)(n.li,{children:"Freshness guarantees and staleness detection"}),"\n",(0,s.jsx)(n.li,{children:"Integration points for third-party verifiers and zero-knowledge proofs"}),"\n",(0,s.jsx)(n.li,{children:"Fraud proof generation for dispute resolution"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Settlement Protocol"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Atomic swap patterns for trustless settlement"}),"\n",(0,s.jsx)(n.li,{children:"Escrow mechanisms and conditional payment release"}),"\n",(0,s.jsx)(n.li,{children:"Multi-chain settlement strategies (chain-agnostic interface)"}),"\n",(0,s.jsx)(n.li,{children:"Failure handling and refund protocols"}),"\n",(0,s.jsx)(n.li,{children:"Settlement finality guarantees"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Trust Model"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reputation systems for providers and consumers"}),"\n",(0,s.jsx)(n.li,{children:"Sybil resistance mechanisms"}),"\n",(0,s.jsx)(n.li,{children:"Provider bonding and slashing conditions"}),"\n",(0,s.jsx)(n.li,{children:"Privacy considerations for sensitive context"}),"\n",(0,s.jsx)(n.li,{children:"Attack vectors and protocol-level mitigations"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"what-lcp-does-not-specify",children:"What LCP Does Not Specify"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Transport Layer"}),": LCP is transport-agnostic. Context can flow over HTTP, WebSocket, gRPC, P2P networks, or any other transport. The protocol defines ",(0,s.jsx)(n.em,{children:"what"})," messages are exchanged, not ",(0,s.jsx)(n.em,{children:"how"})," they are transmitted."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Payment Rails"}),": LCP defines settlement ",(0,s.jsx)(n.em,{children:"interfaces"})," and atomicity guarantees but does not mandate specific payment systems. Implementations can use Ethereum, Bitcoin Lightning, stablecoins, traditional payment processors, or any rail that supports atomic settlement."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Context Schemas"}),": Providers define their own data schemas. LCP specifies how schemas are advertised and negotiated, but does not dictate content structure. This allows domain-specific optimizations (financial data, sensor streams, knowledge graphs, etc.)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Provider Implementation"}),": How providers source, generate, or store context is out of scope. LCP only cares about the interface they expose and the guarantees they make."]}),"\n",(0,s.jsx)(n.h2,{id:"15-value-proposition",children:"1.5 Value Proposition"}),"\n",(0,s.jsx)(n.h3,{id:"for-ai-agent-developers",children:"For AI Agent Developers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Autonomous Operation"}),": Agents discover and transact for context without human intervention"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced Integration Burden"}),": Single protocol replaces countless custom provider integrations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Risk Mitigation"}),": Cryptographic verification and atomic settlement eliminate fraud and payment risk"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cost Optimization"}),": Market-driven pricing through competitive discovery and negotiation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Privacy Preservation"}),": Zero-knowledge proofs enable verification without data exposure"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"for-context-providers",children:"For Context Providers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Permissionless Market Access"}),": Advertise capabilities without platform approval or gatekeepers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automated Monetization"}),": Machine-to-machine transactions at scale without human sales cycles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Guaranteed Payment"}),": Atomic settlement eliminates non-payment risk"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reputation Building"}),": Cryptographic proof of quality builds verifiable track record"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flexible Business Models"}),": Support subscriptions, pay-per-query, tiered pricing, auction-based pricing"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"for-the-ecosystem",children:"For the Ecosystem"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Interoperability"}),": Works alongside MCP (data access), A2A (coordination), existing settlement layers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Market Efficiency"}),": Discovery and negotiation create competitive dynamics that drive quality up and costs down"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Innovation Enablement"}),": Permissionless participation lowers barriers for specialized context providers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Trustless Infrastructure"}),": Reduces systemic risk by eliminating dependency on trusted intermediaries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Privacy by Design"}),": ZKP integration enables high-value use cases (proprietary models, sensitive data) in trustless environments"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"16-relationship-to-existing-protocols",children:"1.6 Relationship to Existing Protocols"}),"\n",(0,s.jsx)(n.p,{children:"LCP is designed for composability with the emerging agentic infrastructure:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Protocol"}),(0,s.jsx)(n.th,{children:"Focus"}),(0,s.jsx)(n.th,{children:"Relationship to LCP"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"MCP"})}),(0,s.jsx)(n.td,{children:"Standardized connections between AI and data sources"}),(0,s.jsx)(n.td,{children:'LCP uses MCP-compatible interfaces for context delivery; MCP handles "how to connect," LCP handles "which provider to use and on what terms"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"A2A"})}),(0,s.jsx)(n.td,{children:"Direct agent-to-agent coordination and negotiation"}),(0,s.jsx)(n.td,{children:'LCP can leverage A2A negotiation primitives for multi-party scenarios; A2A handles "agent cooperation," LCP handles "agent-provider transactions"'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"ERC-8004"})}),(0,s.jsx)(n.td,{children:"On-chain identity, reputation, validation for agents"}),(0,s.jsx)(n.td,{children:"LCP integrates ERC-8004 reputation registries for provider/consumer trust scoring"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"TIVA"})}),(0,s.jsx)(n.td,{children:"Trustless intent verification for autonomous agents"}),(0,s.jsx)(n.td,{children:"LCP adopts similar cryptographic proof patterns for verifying context provenance"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"LCP fills the orchestration gap: the protocol layer that enables agents to autonomously discover unfamiliar providers, negotiate terms, verify claims, and settle payments\u2014the foundation for a permissionless context economy."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);