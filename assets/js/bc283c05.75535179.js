"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[575],{474(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"negotiation","title":"5. Negotiation Protocol","description":"Negotiation enables agents and providers to reach mutually acceptable terms without human intervention. Unlike fixed-price APIs, LCP negotiation allows dynamic pricing, quality trade-offs, and custom arrangements.","source":"@site/docs/negotiation.md","sourceDirName":".","slug":"/negotiation","permalink":"/lcp-spec/docs/negotiation","draft":false,"unlisted":false,"editUrl":"https://github.com/Turf-Tech/lcp-spec/tree/main/website/docs/negotiation.md","tags":[],"version":"current","lastUpdatedBy":"code-wiki","lastUpdatedAt":1770211386000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6,"sidebar_label":"Negotiation Protocol"},"sidebar":"docsSidebar","previous":{"title":"Discovery Protocol","permalink":"/lcp-spec/docs/discovery"},"next":{"title":"Verification Protocol","permalink":"/lcp-spec/docs/verification"}}');var t=i(4848),s=i(8453);const o={sidebar_position:6,sidebar_label:"Negotiation Protocol"},a="5. Negotiation Protocol",l={},c=[{value:"5.1 Design Goals",id:"51-design-goals",level:2},{value:"5.2 Negotiation Phases",id:"52-negotiation-phases",level:2},{value:"Phase 1: Initial Request",id:"phase-1-initial-request",level:3},{value:"Phase 2: Provider Response",id:"phase-2-provider-response",level:3},{value:"Phase 3: Consumer Counter-Proposal (Optional)",id:"phase-3-consumer-counter-proposal-optional",level:3},{value:"Phase 4: Final Response",id:"phase-4-final-response",level:3},{value:"Phase 5: Mutual Commitment",id:"phase-5-mutual-commitment",level:3},{value:"5.3 Negotiation Strategies",id:"53-negotiation-strategies",level:2},{value:"Consumer Strategies",id:"consumer-strategies",level:3},{value:"Anchoring Strategy",id:"anchoring-strategy",level:4},{value:"Tit-for-Tat",id:"tit-for-tat",level:4},{value:"Utility-Maximizing",id:"utility-maximizing",level:4},{value:"Provider Strategies",id:"provider-strategies",level:3},{value:"Cost-Plus Pricing",id:"cost-plus-pricing",level:4},{value:"Dynamic Pricing",id:"dynamic-pricing",level:4},{value:"Reputation Building",id:"reputation-building",level:4},{value:"5.4 Multi-Round Negotiation",id:"54-multi-round-negotiation",level:2},{value:"Convergence Criteria",id:"convergence-criteria",level:3},{value:"Concession Patterns",id:"concession-patterns",level:3},{value:"Monotonic Concessions",id:"monotonic-concessions",level:4},{value:"Alternating Dimensions",id:"alternating-dimensions",level:4},{value:"Zeuthen Strategy",id:"zeuthen-strategy",level:4},{value:"5.5 Multi-Party Negotiation",id:"55-multi-party-negotiation",level:2},{value:"Parallel Negotiation",id:"parallel-negotiation",level:3},{value:"Combinatorial Negotiation",id:"combinatorial-negotiation",level:3},{value:"Auction-Based Negotiation",id:"auction-based-negotiation",level:3},{value:"5.6 Timeout and Failure Handling",id:"56-timeout-and-failure-handling",level:2},{value:"Timeout Configuration",id:"timeout-configuration",level:3},{value:"Timeout Behavior",id:"timeout-behavior",level:3},{value:"Partial Failure Recovery",id:"partial-failure-recovery",level:3},{value:"5.7 Negotiation Privacy",id:"57-negotiation-privacy",level:2},{value:"Privacy-Preserving Techniques",id:"privacy-preserving-techniques",level:3},{value:"Secure Multi-Party Computation (MPC)",id:"secure-multi-party-computation-mpc",level:4},{value:"Zero-Knowledge Range Proofs",id:"zero-knowledge-range-proofs",level:4},{value:"Homomorphic Encryption",id:"homomorphic-encryption",level:4},{value:"5.8 Commitment and Binding",id:"58-commitment-and-binding",level:2},{value:"Commitment Protocol",id:"commitment-protocol",level:3},{value:"On-Chain Commitment (Optional)",id:"on-chain-commitment-optional",level:3},{value:"5.9 Implementation Recommendations",id:"59-implementation-recommendations",level:2},{value:"For Consumers",id:"for-consumers",level:3},{value:"For Providers",id:"for-providers",level:3},{value:"For Protocol Implementers",id:"for-protocol-implementers",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"5-negotiation-protocol",children:"5. Negotiation Protocol"})}),"\n",(0,t.jsx)(n.p,{children:"Negotiation enables agents and providers to reach mutually acceptable terms without human intervention. Unlike fixed-price APIs, LCP negotiation allows dynamic pricing, quality trade-offs, and custom arrangements."}),"\n",(0,t.jsx)(n.h2,{id:"51-design-goals",children:"5.1 Design Goals"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Autonomous Convergence"}),": Agents reach agreement without human oversight"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-Dimensional Terms"}),": Negotiate price, quality, latency, schema, settlement simultaneously"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bounded Latency"}),": Negotiation completes within predictable timeframes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Incentive Compatibility"}),": Both parties benefit from truthful preference revelation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Composability"}),": Integration with A2A-style multi-agent coordination patterns"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"52-negotiation-phases",children:"5.2 Negotiation Phases"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Consumer                                    Provider\n    \u2502                                           \u2502\n    \u2502\u2500\u2500\u2500\u2500\u2500(1) Initial Request\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502\n    \u2502         (consumer's ideal terms)          \u2502\n    \u2502                                           \u2502\n    \u2502\u25c0\u2500\u2500\u2500\u2500(2) Response\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502         (accept | counter | reject)       \u2502\n    \u2502                                           \u2502\n    \u2502\u2500\u2500\u2500\u2500\u2500(3) Counter-Proposal (optional)\u2500\u2500\u2500\u2500\u2500\u25b6\u2502\n    \u2502                                           \u2502\n    \u2502\u25c0\u2500\u2500\u2500\u2500(4) Final Response\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502         (accept | reject)                 \u2502\n    \u2502                                           \u2502\n    \u2502\u2500\u2500\u2500\u2500\u2500(5) Commitment\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n    \u2502         (both parties sign agreement)     \u2502\n    \u2502                                           \u2502\n    \u25bc                                           \u25bc\n   Execution                              Execution\n"})}),"\n",(0,t.jsx)(n.h3,{id:"phase-1-initial-request",children:"Phase 1: Initial Request"}),"\n",(0,t.jsx)(n.p,{children:"Consumer sends desired terms (see 3.2 Context Request):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "request_id": "req_9f3e8d7c6b5a4321",\n  "consumer": {"id": "did:example:agent456"},\n  "capability_id": "cap_realtime_stock_quotes",\n  "parameters": {"symbols": ["AAPL", "GOOGL"]},\n  "terms": {\n    "max_price": {"amount": 0.0015, "currency": "USDC"},\n    "min_guarantees": {\n      "latency_ms": 150,\n      "freshness_ms": 100\n    }\n  },\n  "negotiation_preferences": {\n    "max_rounds": 3,\n    "timeout_seconds": 30,\n    "priority": {\n      "price": 0.6,\n      "latency": 0.3,\n      "freshness": 0.1\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"phase-2-provider-response",children:"Phase 2: Provider Response"}),"\n",(0,t.jsx)(n.p,{children:"Provider evaluates request and responds:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Option A: Accept"})," (consumer's terms are acceptable)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "status": "accepted",\n  "request_id": "req_9f3e8d7c6b5a4321",\n  "accepted_terms": {\n    // Echoes consumer\'s proposed terms\n  },\n  "signature": {...}\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Option B: Counter-Proposal"})," (different terms proposed)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "status": "counter_proposal",\n  "request_id": "req_9f3e8d7c6b5a4321",\n  "proposed_terms": {\n    "price": {"amount": 0.0018, "currency": "USDC"},\n    "guarantees": {\n      "latency_ms": 130,  // Better than requested\n      "freshness_ms": 90   // Better than requested\n    }\n  },\n  "rationale": {\n    "reason": "requested_price_below_cost",\n    "cost_breakdown": {\n      "data_acquisition": 0.0010,\n      "infrastructure": 0.0005,\n      "margin": 0.0003\n    }\n  },\n  "valid_until": "2026-01-29T12:30:20Z",\n  "signature": {...}\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Option C: Reject"})," (cannot fulfill)"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "status": "rejected",\n  "request_id": "req_9f3e8d7c6b5a4321",\n  "reason": "capability_unavailable",\n  "retry_after_seconds": 3600\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"phase-3-consumer-counter-proposal-optional",children:"Phase 3: Consumer Counter-Proposal (Optional)"}),"\n",(0,t.jsx)(n.p,{children:"If provider counter-proposes and consumer wants to continue:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "request_id": "req_9f3e8d7c6b5a4321",\n  "round": 2,\n  "proposed_terms": {\n    "price": {"amount": 0.00165, "currency": "USDC"},  // Split difference\n    "guarantees": {\n      "latency_ms": 130,    // Accept provider\'s better offer\n      "freshness_ms": 90    // Accept provider\'s better offer\n    }\n  },\n  "signature": {...}\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"phase-4-final-response",children:"Phase 4: Final Response"}),"\n",(0,t.jsx)(n.p,{children:"Provider accepts or rejects final terms:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "status": "accepted",\n  "request_id": "req_9f3e8d7c6b5a4321",\n  "final_terms": {\n    "price": {"amount": 0.00165, "currency": "USDC"},\n    "guarantees": {...}\n  },\n  "signature": {...}\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"phase-5-mutual-commitment",children:"Phase 5: Mutual Commitment"}),"\n",(0,t.jsx)(n.p,{children:"Both parties sign the agreed terms, creating a binding commitment:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "agreement_id": "agr_8d7c6b5a4f3e2d1c",\n  "request_id": "req_9f3e8d7c6b5a4321",\n  "final_terms": {...},\n  "signatures": {\n    "consumer": {\n      "signer": "did:example:agent456",\n      "signature": "0x1234..."\n    },\n    "provider": {\n      "signer": "did:example:provider123",\n      "signature": "0x5678..."\n    }\n  },\n  "binding_at": "2026-01-29T12:30:25Z",\n  "expires_at": "2026-01-29T13:30:25Z"  // Agreement valid for 1 hour\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"53-negotiation-strategies",children:"5.3 Negotiation Strategies"}),"\n",(0,t.jsx)(n.h3,{id:"consumer-strategies",children:"Consumer Strategies"}),"\n",(0,t.jsx)(n.h4,{id:"anchoring-strategy",children:"Anchoring Strategy"}),"\n",(0,t.jsx)(n.p,{children:"Start with aggressive terms to anchor negotiation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def anchor_strategy(market_price):\n    return {\n        "price": market_price * 0.7,  # 30% below market\n        "latency": market_latency * 0.8  # 20% better latency\n    }\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Risk"}),": Provider may reject immediately if too aggressive"]}),"\n",(0,t.jsx)(n.h4,{id:"tit-for-tat",children:"Tit-for-Tat"}),"\n",(0,t.jsx)(n.p,{children:"Mirror provider's concession magnitude:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def tit_for_tat(provider_offer, previous_consumer_offer):\n    provider_concession = provider_offer.price - previous_provider_offer.price\n    return {\n        "price": previous_consumer_offer.price + provider_concession\n    }\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Builds cooperative relationship, converges to fair split"]}),"\n",(0,t.jsx)(n.h4,{id:"utility-maximizing",children:"Utility-Maximizing"}),"\n",(0,t.jsx)(n.p,{children:"Optimize across multiple dimensions based on preference weights:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def utility_maximizing(provider_offer, preferences):\n    utility = (\n        preferences.price_weight * price_utility(provider_offer.price) +\n        preferences.latency_weight * latency_utility(provider_offer.latency) +\n        preferences.quality_weight * quality_utility(provider_offer.quality)\n    )\n    if utility >= preferences.min_acceptable_utility:\n        return "accept"\n    else:\n        return generate_counter_offer(utility_gap)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"provider-strategies",children:"Provider Strategies"}),"\n",(0,t.jsx)(n.h4,{id:"cost-plus-pricing",children:"Cost-Plus Pricing"}),"\n",(0,t.jsx)(n.p,{children:"Never go below cost, apply standard margin:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def cost_plus(consumer_request):\n    cost = calculate_cost(consumer_request)\n    if consumer_request.max_price >= cost * (1 + MIN_MARGIN):\n        return "accept"\n    else:\n        return {"price": cost * (1 + STANDARD_MARGIN)}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"dynamic-pricing",children:"Dynamic Pricing"}),"\n",(0,t.jsx)(n.p,{children:"Adjust price based on current demand and capacity:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def dynamic_pricing(consumer_request, current_load):\n    base_price = calculate_base_price(consumer_request)\n\n    if current_load < 0.5:  # Low utilization\n        return base_price * 0.9  # Discount to attract business\n    elif current_load > 0.9:  # High utilization\n        return base_price * 1.3  # Premium for scarce capacity\n    else:\n        return base_price\n"})}),"\n",(0,t.jsx)(n.h4,{id:"reputation-building",children:"Reputation Building"}),"\n",(0,t.jsx)(n.p,{children:"Accept lower prices early to build transaction history:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def reputation_building(consumer_request, provider_transaction_count):\n    if provider_transaction_count < 100:  # New provider\n        return min(consumer_request.max_price, cost * 1.05)  # Minimal margin\n    else:\n        return cost * (1 + STANDARD_MARGIN)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"54-multi-round-negotiation",children:"5.4 Multi-Round Negotiation"}),"\n",(0,t.jsx)(n.h3,{id:"convergence-criteria",children:"Convergence Criteria"}),"\n",(0,t.jsx)(n.p,{children:"Negotiation terminates when:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Agreement Reached"}),": Both parties accept terms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Max Rounds Exceeded"}),": Iteration limit reached (typically 3-5 rounds)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timeout"}),": Time limit exceeded (typically 30-60 seconds)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Utility Gap Too Large"}),": Parties' requirements don't overlap"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Explicit Rejection"}),": Either party terminates"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"concession-patterns",children:"Concession Patterns"}),"\n",(0,t.jsx)(n.h4,{id:"monotonic-concessions",children:"Monotonic Concessions"}),"\n",(0,t.jsx)(n.p,{children:"Each party makes smaller concessions over time:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Round 1: Consumer offers $0.001, Provider counters $0.002\nRound 2: Consumer offers $0.0013, Provider counters $0.0018\nRound 3: Consumer offers $0.0015, Provider accepts\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Concession decay: ",(0,t.jsx)(n.code,{children:"concession[n] = initial_gap * 0.4^n"})]}),"\n",(0,t.jsx)(n.h4,{id:"alternating-dimensions",children:"Alternating Dimensions"}),"\n",(0,t.jsx)(n.p,{children:"Trade off different terms across rounds:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Round 1: Negotiate price\nRound 2: Given price agreement, negotiate latency\nRound 3: Given price + latency, negotiate settlement terms\n"})}),"\n",(0,t.jsx)(n.p,{children:"Reduces dimensionality, simplifies convergence."}),"\n",(0,t.jsx)(n.h4,{id:"zeuthen-strategy",children:"Zeuthen Strategy"}),"\n",(0,t.jsx)(n.p,{children:'Party with lower "risk of conflict" (utility loss from non-agreement) concedes:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def zeuthen_strategy(my_utility_current, my_utility_if_reject,\n                      opponent_utility_current, opponent_utility_if_reject):\n    my_risk = (my_utility_current - my_utility_if_reject) / my_utility_current\n    opponent_risk = (opponent_utility_current - opponent_utility_if_reject) / opponent_utility_current\n\n    if my_risk < opponent_risk:\n        return "i_concede"\n    else:\n        return "wait_for_opponent"\n'})}),"\n",(0,t.jsx)(n.p,{children:"Proven to converge to Nash bargaining solution."}),"\n",(0,t.jsx)(n.h2,{id:"55-multi-party-negotiation",children:"5.5 Multi-Party Negotiation"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes agents need context from multiple providers simultaneously (e.g., aggregating data sources)."}),"\n",(0,t.jsx)(n.h3,{id:"parallel-negotiation",children:"Parallel Negotiation"}),"\n",(0,t.jsx)(n.p,{children:"Negotiate with multiple providers independently, select best:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async function parallelNegotiation(providers: Provider[], request: Request) {\n  const negotiations = providers.map(p => negotiate(p, request))\n  const results = await Promise.allSettled(negotiations)\n\n  const successful = results.filter(r => r.status === 'fulfilled' && r.value.status === 'accepted')\n  return selectBest(successful, request.preferences)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Single data source, multiple potential providers"]}),"\n",(0,t.jsx)(n.h3,{id:"combinatorial-negotiation",children:"Combinatorial Negotiation"}),"\n",(0,t.jsx)(n.p,{children:"Negotiate terms where value depends on combination of providers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async function combinatorialNegotiation(providers: Provider[], request: Request) {\n  // Request is only valuable if ALL providers agree\n  const offers = await Promise.all(\n    providers.map(p => p.requestOffer(request))\n  )\n\n  const totalCost = offers.reduce((sum, o) => sum + o.price, 0)\n\n  if (totalCost <= request.max_budget) {\n    return acceptAll(offers)\n  } else {\n    // Attempt to renegotiate with all providers\n    const reducedOffers = await renegotiateGroup(providers, request.max_budget)\n    return reducedOffers\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Multi-source aggregation (e.g., merging datasets from 3 providers)"]}),"\n",(0,t.jsx)(n.h3,{id:"auction-based-negotiation",children:"Auction-Based Negotiation"}),"\n",(0,t.jsx)(n.p,{children:"Providers bid for consumer's business:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"async function auctionNegotiation(providers: Provider[], request: Request) {\n  // Sealed-bid auction\n  const bids = await Promise.all(\n    providers.map(p => p.submitSealedBid(request))\n  )\n\n  // Second-price auction (Vickrey)\n  const sortedBids = bids.sort((a, b) => a.price - b.price)\n  const winner = sortedBids[0]\n  const paymentPrice = sortedBids[1].price  // Pay second-lowest price\n\n  return {\n    provider: winner.provider,\n    terms: {...winner.terms, price: paymentPrice}\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),": Incentive-compatible (truthful bidding is optimal), efficient price discovery"]}),"\n",(0,t.jsx)(n.h2,{id:"56-timeout-and-failure-handling",children:"5.6 Timeout and Failure Handling"}),"\n",(0,t.jsx)(n.h3,{id:"timeout-configuration",children:"Timeout Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "negotiation_timeouts": {\n    "first_response_ms": 5000,      // Provider must respond within 5s\n    "per_round_ms": 10000,           // Each subsequent round: 10s\n    "total_negotiation_ms": 30000,   // Overall negotiation limit: 30s\n    "commitment_window_ms": 5000     // Time to sign agreement: 5s\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"timeout-behavior",children:"Timeout Behavior"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Provider Timeout"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "error": {\n    "code": "NEGOTIATION_TIMEOUT",\n    "message": "Provider did not respond within 5000ms",\n    "failed_at": "2026-01-29T12:30:10Z"\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Consumer moves to next provider in discovery results."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Consumer Timeout"}),":\nProvider's offer expires:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "status": "offer_expired",\n  "reason": "Consumer did not respond before valid_until",\n  "expired_at": "2026-01-29T12:30:20Z"\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"partial-failure-recovery",children:"Partial Failure Recovery"}),"\n",(0,t.jsx)(n.p,{children:"If negotiation fails partway through:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Log Interaction"}),": Record negotiation attempt for reputation system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Retry with Adjusted Terms"}),": Consumer may retry with less aggressive initial offer"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Move to Next Provider"}),": Try different provider from discovery results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Escalate to Human"}),": If all automated attempts fail (optional)"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"57-negotiation-privacy",children:"5.7 Negotiation Privacy"}),"\n",(0,t.jsx)(n.p,{children:"Negotiation reveals information about preferences and constraints."}),"\n",(0,t.jsx)(n.h3,{id:"privacy-preserving-techniques",children:"Privacy-Preserving Techniques"}),"\n",(0,t.jsx)(n.h4,{id:"secure-multi-party-computation-mpc",children:"Secure Multi-Party Computation (MPC)"}),"\n",(0,t.jsx)(n.p,{children:"Compute agreement zone without revealing exact preferences:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Consumer: "My max price is X" (secret)\nProvider: "My min price is Y" (secret)\n\nMPC Protocol: Compute whether X >= Y (reveals only yes/no)\n\nIf yes: Run secondary protocol to find fair price in [Y, X] without revealing bounds\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Parties learn only whether agreement is possible, not full preferences"]}),"\n",(0,t.jsx)(n.h4,{id:"zero-knowledge-range-proofs",children:"Zero-Knowledge Range Proofs"}),"\n",(0,t.jsx)(n.p,{children:"Prove price is within acceptable range without revealing exact value:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "price_commitment": "0x2c26b46b...",\n  "zk_proof": {\n    "type": "range_proof",\n    "claim": "committed_price >= 0.001 AND committed_price <= 0.002",\n    "proof": "0x5f7a8e9c..."\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Provider proves to consumer that offered price is within posted range without revealing exact price (useful for discriminatory pricing)"]}),"\n",(0,t.jsx)(n.h4,{id:"homomorphic-encryption",children:"Homomorphic Encryption"}),"\n",(0,t.jsx)(n.p,{children:"Negotiate over encrypted terms:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Consumer encrypts max_price with provider's public key\nProvider computes encrypted_comparison(encrypted_max_price, min_price)\nResult reveals only whether negotiation can proceed\n"})}),"\n",(0,t.jsx)(n.h2,{id:"58-commitment-and-binding",children:"5.8 Commitment and Binding"}),"\n",(0,t.jsx)(n.p,{children:"Once terms are agreed, both parties must commit atomically."}),"\n",(0,t.jsx)(n.h3,{id:"commitment-protocol",children:"Commitment Protocol"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"1. Provider creates agreement document with final terms\n2. Provider signs agreement \u2192 signature_p\n3. Consumer receives signed agreement\n4. Consumer verifies provider signature\n5. Consumer signs agreement \u2192 signature_c\n6. Consumer sends dual-signed agreement to provider\n7. Provider verifies both signatures\n8. Agreement is now binding on both parties\n"})}),"\n",(0,t.jsx)(n.h3,{id:"on-chain-commitment-optional",children:"On-Chain Commitment (Optional)"}),"\n",(0,t.jsx)(n.p,{children:"For high-value transactions, commit agreement hash on-chain:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:'contract LCPAgreementRegistry {\n  struct Agreement {\n    bytes32 agreementHash;\n    address consumer;\n    address provider;\n    uint256 commitmentTimestamp;\n    uint256 expiryTimestamp;\n  }\n\n  mapping(bytes32 => Agreement) public agreements;\n\n  function commitAgreement(\n    bytes32 agreementHash,\n    address provider,\n    uint256 expiryTimestamp,\n    bytes calldata consumerSignature,\n    bytes calldata providerSignature\n  ) external {\n    // Verify signatures\n    require(verifySignatures(...), "Invalid signatures");\n\n    // Store commitment\n    agreements[agreementHash] = Agreement({\n      agreementHash: agreementHash,\n      consumer: msg.sender,\n      provider: provider,\n      commitmentTimestamp: block.timestamp,\n      expiryTimestamp: expiryTimestamp\n    });\n\n    emit AgreementCommitted(agreementHash, msg.sender, provider);\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Immutable record of agreement"}),"\n",(0,t.jsx)(n.li,{children:"Enables on-chain dispute resolution"}),"\n",(0,t.jsx)(n.li,{children:"Integrates with settlement contracts"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"59-implementation-recommendations",children:"5.9 Implementation Recommendations"}),"\n",(0,t.jsx)(n.h3,{id:"for-consumers",children:"For Consumers"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Set Realistic Timeouts"}),": Allow sufficient time for multi-round negotiation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parallel Negotiation"}),": Query multiple providers simultaneously to maximize options"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Preference Calibration"}),": Test utility functions against market outcomes to refine weights"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graceful Degradation"}),": If ideal terms unreachable, accept suboptimal but acceptable terms"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"for-providers",children:"For Providers"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fast Initial Response"}),": Respond within 1-2 seconds to avoid timeout"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transparent Rationale"}),": Include cost breakdown in counter-proposals to build trust"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic Pricing"}),": Adjust prices based on utilization and demand"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Commitment Honoring"}),": Never renege on signed agreements (reputation damage)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"for-protocol-implementers",children:"For Protocol Implementers"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timeout Enforcement"}),": Strictly enforce timeouts to prevent hanging negotiations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Signature Verification"}),": Always verify signatures before treating agreements as binding"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Replay Protection"}),": Use nonces in all negotiation messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Audit Logging"}),": Record full negotiation history for dispute resolution and learning"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>o,x:()=>a});var r=i(6540);const t={},s=r.createContext(t);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);